package eu.piacere.doml.grammar.generator.ui.handlers;

import java.io.File;
import java.io.Writer;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.resources.IFile;
import org.eclipse.emf.ecore.EcorePackage;
//import org.eclipse.emf.ecore.presentation.EcoreEditor;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.*;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.handlers.HandlerUtil;
import org.eclipse.xtext.XtextPackage;

import eu.piacere.doml.grammar.generator.common.DomlGrammarBuilder;
import eu.piacere.doml.grammar.generator.common.DomlGrammarBuilder.DomlGrammarBuilderException;

/**
 * @author Sergio Canzoneri, Politecnico di Milano
 * 
 * The handler used for the DOML-E "Generate Grammar" command.
 */
public class GenerateGrammarHandler extends AbstractHandler {
	
	// File extension for Ecore model.
	public static final String ECORE_FILE_EXTENSION = EcorePackage.eNS_PREFIX;
	// This could be EcoreEditor.ECORE_FILE_EXTENSION, but that's actually the same value.
	
	// File extension for Xtext grammar.
	public static final String XTEXT_FILE_EXTENSION = XtextPackage.eNS_PREFIX;
	// Please note that there is no corresponding constant constant field value for file extension in Xtext.
	
	// List of the Ecore selected files.
	private List<IFile> selectedEcoreFiles;
	
	// DomlGrammarBuilder object (static class) to be used to generate all the required Xtext files.
	private DomlGrammarBuilder domlGrammarBuilder;

	@Override
	// Handler for a command to generate Xtext grammar files from DOML ecore.
	public Object execute(ExecutionEvent event) throws ExecutionException {
		selectedEcoreFiles = getSelectedElements(HandlerUtil.getCurrentSelection(event));
		
		// Gets a singleton instance of DomlGrammarBuilder.
		domlGrammarBuilder = DomlGrammarBuilder.getInstance();
		
		for(IFile file : selectedEcoreFiles) {
				
			IWorkbenchWindow window = HandlerUtil.getActiveWorkbenchWindowChecked(event);
			
			/*
			 * Asks the user to select a JSON configuration file.
			 * This special file should contain relevant pieces of information, including:
			 * - Keywords to be used for classes, attributes and references
			 * - If present, information on enumeration attributes to replace specific keywords
			 * - Enclosing symbols chosen by users for multiple attributes and references
			 * - Fixed content to be loaded, if modified from current DOML latest version (3.1)
			 */
			FileDialog jsonDialog = new FileDialog(window.getShell());
			jsonDialog.setFilterPath(file.getRawLocation().uptoSegment(file.getRawLocation().segmentCount()-1).toString());
			jsonDialog.setText("Please select the JSON configuration file to be used for " + file.getName() + '.');
			String[] extensions = {"*.json"};
			jsonDialog.setFilterExtensions(extensions);
			
			String json = jsonDialog.open();

			/*
			 * If the JSON file has been opened correctly, then it sets its path for the
			 * DomlGrammarBuilder to dynamically load its content.
			 * Then the user is asked whether they want to load DOML fixed content through
			 * a simple dialog: if they choose to do so, then the content stored within
			 * the builder (fixed content for DOML 3.1) is replaced by the one put in the
			 * JSON file using some special keys.
			 * 
			 * Otherwise, a message is shown in the console specifying that no configuration
			 * file was loaded and that keywords will be automatically generated.
			 */
			if(json != null) {
				domlGrammarBuilder.setJsonFilePath(json);
				
				MessageBox loadFixedContentFromJsonDialog = new MessageBox(window.getShell(), SWT.ICON_QUESTION | SWT.YES | SWT.NO);
				loadFixedContentFromJsonDialog.setMessage("JSON configuration file found. Would you wish to load DOML fixed content from file?");
				loadFixedContentFromJsonDialog.setText("Import DOML fixed content.");
				int loadFixedContentFromJsonReply = loadFixedContentFromJsonDialog.open();
				if(loadFixedContentFromJsonReply == SWT.YES) {
					domlGrammarBuilder.loadFixedRulesFromJson();
				}
			}
			else {
				System.out.println("No configuration file loaded. DOML keywords will be generated automatically.");
			}
			
			/*
			 * The Xtext grammar is generated by using the DomlGrammarBuilder.
			 * If the process finishes correctly, then the user is asked to select
			 * a directory where the newly generated Xtext syntax file will be stored.
			 */
			StringBuilder xtextGrammar;
			try {
				xtextGrammar = domlGrammarBuilder.generateGrammar(file);
				DirectoryDialog dialog = new DirectoryDialog(window.getShell());
				dialog.setFilterPath(file.getRawLocation().uptoSegment(file.getRawLocation().segmentCount()-1).toString());
		        dialog.setText("DOML Grammar Path for " + file.getName() + '.');
		        dialog.setMessage("Please select the folder to which you desire to save the newly generated Xtext file.");

		        String dir = dialog.open();
		        if (dir != null) {
	        		String filePath = dir + '/' + file.getName().substring(0, file.getName().lastIndexOf(ECORE_FILE_EXTENSION)) + XTEXT_FILE_EXTENSION;
					File xtextFile = new File(filePath); 
					try {
						xtextFile.createNewFile();
						Writer targetFileWriter = new FileWriter(xtextFile); targetFileWriter.write(xtextGrammar.toString());
						targetFileWriter.close(); 
					} catch (IOException e) { 
						e.printStackTrace(); 
					}
		        }
			} catch (DomlGrammarBuilderException e) {
				e.printStackTrace();
			}
			
		}
		
		return null;
	}
	
	// Get the elements the user has selected in the Eclipse environment.
	private List<IFile> getSelectedElements(ISelection selection) {
		final List<IFile> elements = new ArrayList<IFile>();
		if (selection != null && selection instanceof IStructuredSelection) {
			final IStructuredSelection structuredSelection = (IStructuredSelection) selection;
			for(Object object : structuredSelection.toList()) {
				if (!IFile.class.isInstance(object)) {
					continue;
				}
				if(IFile.class.cast(object).getFileExtension().equals(ECORE_FILE_EXTENSION))
				{
					elements.add(IFile.class.cast(object));
				}
			}
		}
		return elements;
	}
}
